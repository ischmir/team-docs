{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DBI Dashboard Project Documentation Introduction Welcome to the official documentation for our team! This site serves as a comprehensive guide to our team's guidelines, processes, and resources. Here you will find valuable information to help you navigate and contribute to our projects effectively. Our goal is to maintain a clear and organized repository of knowledge that supports our team's collaboration and productivity. Here, you will find everything from team guidelines and best practices to detailed project documentation and helpful resources. Quick Links Getting Started Team Guidelines Tips'n Tricks mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project Layout FAQ Check for grammatical errors.","title":"Home"},{"location":"#dbi-dashboard-project-documentation","text":"","title":"DBI Dashboard Project Documentation"},{"location":"#introduction","text":"Welcome to the official documentation for our team! This site serves as a comprehensive guide to our team's guidelines, processes, and resources. Here you will find valuable information to help you navigate and contribute to our projects effectively. Our goal is to maintain a clear and organized repository of knowledge that supports our team's collaboration and productivity. Here, you will find everything from team guidelines and best practices to detailed project documentation and helpful resources.","title":"Introduction"},{"location":"#quick-links","text":"Getting Started Team Guidelines","title":"Quick Links"},{"location":"#tipsn-tricks","text":"mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Tips'n Tricks"},{"location":"#project-layout","text":"","title":"Project Layout"},{"location":"#faq","text":"Check for grammatical errors.","title":"FAQ"},{"location":"about/","text":"About Project Overview This project is a collaborative effort to develop a modern dashboard for DBI. The dashboard aims to improve user experience, streamline workflows, and provide valuable insights through data visualization. The Team Design Team - \ud83c\udf4d Anna Hansen - \ud83d\ude38 Kathrine Lund Jensen - \ud83d\udc26\u200d\u2b1b Laurids Ravn Hansen - \ud83d\udc0d Gina Pantikainen Developer Team - \ud83e\udd20 Mai Jockwich - \ud83e\udd84 Timm Hinsch Collaboration This project was developed in collaboration with Digital Concept Development students, who contributed to the design and user experience aspects of the dashboard. Technologies Used Frontend: Vue.js, Sass Backend as a Service: Firestore Other Tools: GitHub, Figma, MkDocs Acknowledgments We would like to thank our mentors and DBI for their guidance and support throughout the project.","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#project-overview","text":"This project is a collaborative effort to develop a modern dashboard for DBI. The dashboard aims to improve user experience, streamline workflows, and provide valuable insights through data visualization.","title":"Project Overview"},{"location":"about/#the-team","text":"Design Team - \ud83c\udf4d Anna Hansen - \ud83d\ude38 Kathrine Lund Jensen - \ud83d\udc26\u200d\u2b1b Laurids Ravn Hansen - \ud83d\udc0d Gina Pantikainen Developer Team - \ud83e\udd20 Mai Jockwich - \ud83e\udd84 Timm Hinsch","title":"The Team"},{"location":"about/#collaboration","text":"This project was developed in collaboration with Digital Concept Development students, who contributed to the design and user experience aspects of the dashboard.","title":"Collaboration"},{"location":"about/#technologies-used","text":"Frontend: Vue.js, Sass Backend as a Service: Firestore Other Tools: GitHub, Figma, MkDocs","title":"Technologies Used"},{"location":"about/#acknowledgments","text":"We would like to thank our mentors and DBI for their guidance and support throughout the project.","title":"Acknowledgments"},{"location":"architectureAndTechnology/","text":"Architecture and Tech Stack Documentation Introduction This document provides an overview of the system architecture and the technologies used in the project. It explains the structure of the system, the rationale behind technology choices. System Architecture The system is built using a modern web application architecture, consisting of the following components: Frontend: Built with Vue.js for a dynamic and responsive user interface. Database: Firestore for real-time data storage and synchronization. Authentication: Firebase Authentication for secure user login. State Management: Pinia for managing application state. Tech Stack Vite Purpose: A modern build tool that serves and bundles your frontend application Why Chosen: Offers fast development startup and hot module replacement (HMR), making it ideal for modern JavaScript frameworks like Vue. Usage: Used as the development server and build tool for the project. It handles compiling, bundling, and optimizing Vue components, styles (like Sass), and static assets. Vue.js Purpose: Frontend framework for building user interfaces. Why Chosen: Provides a reactive and component-based architecture, making it easy to build and maintain the UI. Usage: Used for creating the dashboard and data visualization components. Sass Purpose: CSS preprocessor for styling. Why Chosen: Enables modular and reusable styles with variables, nesting, mixins and partials. Usage: Used for styling the application with a consistent design system. Firebase / Firestore Purpose: Backend-as-a-Service (BaaS) for real-time database and authentication. Why Chosen: Simplifies backend development and provides real-time data synchronization. Usage: Used for storing user data and managing authentication. Pinia Purpose: State management library for Vue.js. Why Chosen: Lightweight and easy to integrate with Vue.js. Usage: Used for managing global application state. ESLint Purpose: Linter for identifying and fixing code issues. Why Chosen: Ensures code quality and consistency. Usage: Configured to enforce coding standards across the project. Snyk Purpose: Security tool for identifying vulnerabilities in dependencies. Why Chosen: Helps maintain a secure codebase. Usage: Integrated into the CI/CD pipeline to scan for vulnerabilities. SonarCloud/SonarQube Purpose: Tool for analysing the quality of the code base. Why Chosen: Scans code for bugs, vulnerability, code smells and duplicates. Usage: Integrates in CI/CD pipeline for secure code quality on every commit or pull request. Cypress Purpose: Tool for end to end testing Why Chosen: Tests the entire user journey in the browser as a real user would experience it. Usage: Tests that the entire application works correctly \u2014 for example, login flow, forms, or navigation. Jest Purpose: Tool for unit testing Why Chosen: Tests individual functions or components for correct functionality. Usage: Used to secure that the logic in e.g. functions works as expected.","title":"Architecture and Technology"},{"location":"architectureAndTechnology/#architecture-and-tech-stack-documentation","text":"","title":"Architecture and Tech Stack Documentation"},{"location":"architectureAndTechnology/#introduction","text":"This document provides an overview of the system architecture and the technologies used in the project. It explains the structure of the system, the rationale behind technology choices.","title":"Introduction"},{"location":"architectureAndTechnology/#system-architecture","text":"The system is built using a modern web application architecture, consisting of the following components: Frontend: Built with Vue.js for a dynamic and responsive user interface. Database: Firestore for real-time data storage and synchronization. Authentication: Firebase Authentication for secure user login. State Management: Pinia for managing application state.","title":"System Architecture"},{"location":"architectureAndTechnology/#tech-stack","text":"","title":"Tech Stack"},{"location":"architectureAndTechnology/#vite","text":"Purpose: A modern build tool that serves and bundles your frontend application Why Chosen: Offers fast development startup and hot module replacement (HMR), making it ideal for modern JavaScript frameworks like Vue. Usage: Used as the development server and build tool for the project. It handles compiling, bundling, and optimizing Vue components, styles (like Sass), and static assets.","title":"Vite"},{"location":"architectureAndTechnology/#vuejs","text":"Purpose: Frontend framework for building user interfaces. Why Chosen: Provides a reactive and component-based architecture, making it easy to build and maintain the UI. Usage: Used for creating the dashboard and data visualization components.","title":"Vue.js"},{"location":"architectureAndTechnology/#sass","text":"Purpose: CSS preprocessor for styling. Why Chosen: Enables modular and reusable styles with variables, nesting, mixins and partials. Usage: Used for styling the application with a consistent design system.","title":"Sass"},{"location":"architectureAndTechnology/#firebase-firestore","text":"Purpose: Backend-as-a-Service (BaaS) for real-time database and authentication. Why Chosen: Simplifies backend development and provides real-time data synchronization. Usage: Used for storing user data and managing authentication.","title":"Firebase / Firestore"},{"location":"architectureAndTechnology/#pinia","text":"Purpose: State management library for Vue.js. Why Chosen: Lightweight and easy to integrate with Vue.js. Usage: Used for managing global application state.","title":"Pinia"},{"location":"architectureAndTechnology/#eslint","text":"Purpose: Linter for identifying and fixing code issues. Why Chosen: Ensures code quality and consistency. Usage: Configured to enforce coding standards across the project.","title":"ESLint"},{"location":"architectureAndTechnology/#snyk","text":"Purpose: Security tool for identifying vulnerabilities in dependencies. Why Chosen: Helps maintain a secure codebase. Usage: Integrated into the CI/CD pipeline to scan for vulnerabilities.","title":"Snyk"},{"location":"architectureAndTechnology/#sonarcloudsonarqube","text":"Purpose: Tool for analysing the quality of the code base. Why Chosen: Scans code for bugs, vulnerability, code smells and duplicates. Usage: Integrates in CI/CD pipeline for secure code quality on every commit or pull request.","title":"SonarCloud/SonarQube"},{"location":"architectureAndTechnology/#cypress","text":"Purpose: Tool for end to end testing Why Chosen: Tests the entire user journey in the browser as a real user would experience it. Usage: Tests that the entire application works correctly \u2014 for example, login flow, forms, or navigation.","title":"Cypress"},{"location":"architectureAndTechnology/#jest","text":"Purpose: Tool for unit testing Why Chosen: Tests individual functions or components for correct functionality. Usage: Used to secure that the logic in e.g. functions works as expected.","title":"Jest"},{"location":"endToEndTesting/","text":"End-to-End Testing Compared to unit tests, which are fast and focused, End-to-End tests has some limitations. Therefore of we only focus on testing the critical paths. End-to-End Tests limitations Slower run than other tests. More complex to setup and maintain. More prone to flakiness. Ressource intensive. Have in mind In the real world users might come upon unexpected issues that an end-to-end test cannot catch. e.g. - Database connection might time out. - Race conditions between services. - Authentication tokens might expire mid-flow. - Network latency might cause unexpected timeouts. When do we use End-to-End tests Critical user journeys. Complex workflows spanning multiple pages/views. Features involving multiple services or third-party systems. Areas with high business value. How to run a End-to-End test To run a test you need to start the server first, You can do that by typing the command below into your CLI. Make sure you are in the project folder. npm run dev Next You will want to run the tests. you can do it in the CLI or more visually using the cypress interactive mode. To run the test in the CLI type the command below in your CLI. npm run test:e2e You can aslo run a specific test by using the command below. npm run test:e2e -- --spec \"cypress/e2e/LoginComp.cy.js\" // or using npx npx run test:e2e --spec \"cypress/e2e/LoginComp.cy.js\" To run the test in cypress interactive mode type the command below. npm cypress open choose E2E Testing followed by a browser. It will open a browser showing all E2E your tests. Simply choose the one you want to run. Notice when using the Cypress interactive mode, everytime you save a file it runs a test. Example of a End-to-End Test in the DBI Dashboard Signup FLow This flow tests: Redirecting from the login view to register Password validation Successfull registration describe('Redirect from login to register view', () => { beforeEach(() => { cy.visit('/login'); }); it('should redirect to register page when clicking on register link', () => { cy.get('[data-cy=\"register-link\"]').click(); cy.url().should('include', '/register'); }); }); describe('Register password validation', () => { beforeEach(() => { cy.visit('/register'); cy.get('[data-cy=\"register-name\"]').type('Test User'); cy.get('[data-cy=\"register-email\"]').type(`testuser${Date.now()}@example.com`); }); it('shows error for missing lowercase letter', () => { cy.get('[data-cy=\"register-password\"]').type('PASSWORD123!@#PASSWORD'); cy.get('[data-cy=\"register-confirm-password\"]').type('PASSWORD123!@#PASSWORD'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Adgangskode skal indeholde mindst \u00e9t lille bogstav.').should('be.visible'); }); it('shows error for missing uppercase letter', () => { cy.get('[data-cy=\"register-password\"]').type('password123!@#password'); cy.get('[data-cy=\"register-confirm-password\"]').type('password123!@#password'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Adgangskode skal indeholde mindst \u00e9t stort bogstav.').should('be.visible'); }); it('shows error for missing number', () => { cy.get('[data-cy=\"register-password\"]').type('Password!@#Password!'); cy.get('[data-cy=\"register-confirm-password\"]').type('Password!@#Password!'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Adgangskode skal indeholde mindst \u00e9t tal.').should('be.visible'); }); it('shows error for missing special character', () => { cy.get('[data-cy=\"register-password\"]').type('Password1234Password'); cy.get('[data-cy=\"register-confirm-password\"]').type('Password1234Password'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Adgangskode skal indeholde minst et specialtegn.').should('be.visible'); }); it('shows error for password too short', () => { cy.get('[data-cy=\"register-password\"]').type('Pass1!'); cy.get('[data-cy=\"register-confirm-password\"]').type('Pass1!'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Adgangskode skal indeholde mindst 16 tegn.').should('be.visible'); }); it('shows multiple errors for a very weak password', () => { cy.get('[data-cy=\"register-password\"]').type('abc'); cy.get('[data-cy=\"register-confirm-password\"]').type('abc'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Adgangskode skal indeholde mindst \u00e9t stort bogstav.').should('be.visible'); cy.contains('Adgangskode skal indeholde mindst \u00e9t tal.').should('be.visible'); cy.contains('Adgangskode skal indeholde minst et specialtegn.').should('be.visible'); cy.contains('Adgangskode skal indeholde mindst 16 tegn.').should('be.visible'); }); it('shows error if passwords do not match', () => { cy.get('[data-cy=\"register-password\"]').type('ValidPassword123!@#'); cy.get('[data-cy=\"register-confirm-password\"]').type('DifferentPassword123!@#'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Adgangskoder stemmer ikke overens.').should('be.visible'); }); }); describe('Register flow', () => { beforeEach(() => { cy.visit('/register'); }); it('shows error for email already in use', () => { cy.get('[data-cy=\"register-name\"]').type('Test User'); cy.get('[data-cy=\"register-email\"]').type('test@mail.com'); cy.get('[data-cy=\"register-password\"]').type('ValidPassword123!@#'); cy.get('[data-cy=\"register-confirm-password\"]').type('ValidPassword123!@#'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Ugyldig email').should('be.visible'); }); it('registers a new user with valid data', () => { const uniqueEmail = `testuser${Date.now()}@example.com`; cy.get('[data-cy=\"register-name\"]').type('Test User'); cy.get('[data-cy=\"register-email\"]').type(uniqueEmail); cy.get('[data-cy=\"register-password\"]').type('ValidPassword123!@#'); cy.get('[data-cy=\"register-confirm-password\"]').type('ValidPassword123!@#'); cy.get('[data-cy=\"register-submit\"]').click(); cy.url().should('include', '/dashboard'); }); }); Login Flow This flow tests: Error handling Successful login redirecting to the dashboard when successfully logging in. describe('Login flow', () => { beforeEach(() => { cy.visit('/login'); }); it('shows error message when the credentials are wrong', () => { cy.get('[data-cy=\"login-email\"]').type('wrong@mail.com'); cy.get('[data-cy=\"login-password\"]').type('wrongpassword'); cy.get('[data-cy=\"login-submit\"]').click(); cy.contains('Forkert email eller adgangskode.').should('be.visible'); }); it('logs in using the right credentials', () => { cy.get('[data-cy=\"login-email\"]').type('test@mail.com'); cy.get('[data-cy=\"login-password\"]').type('password123'); cy.get('[data-cy=\"login-submit\"]').click(); // Expect redirect to dashboard page cy.url().should('include', '/dashboard'); cy.contains('Dashboard').should('exist'); }); }); Edit existing form When user wants to edit an existing form. describe('create form modal flow', () => { beforeEach(() => { cy.visit('/login'); cy.get('[data-cy=\"login-email\"]').type('test@mail.com'); cy.get('[data-cy=\"login-password\"]').type('password123'); cy.get('[data-cy=\"login-submit\"]').click(); cy.url().should('include', '/dashboard'); cy.contains('Dashboard').should('exist'); }); it('edit form in form editor', () => { cy.visit('/form-editor/liqwC3KrFzmrhskGFRs7'); cy.contains('Skema Titel').should('exist'); cy.get('[data-cy=\"form-title-input\"]').clear(); cy.get('[data-cy=\"form-title-input\"]').type('Mit nye skema'); cy.get('[data-cy=\"save-form-btn\"]').click(); }); }); Create New Form Flow When a user wants to create a new form. Clicks create new form button. Fills in needed information in the form. Creates a form using the drag and drop editor. Save the changes A popup shows saved confirmation. Gets redirected to the form overview.","title":"End-to-End Testing"},{"location":"endToEndTesting/#end-to-end-testing","text":"Compared to unit tests, which are fast and focused, End-to-End tests has some limitations. Therefore of we only focus on testing the critical paths.","title":"End-to-End Testing"},{"location":"endToEndTesting/#end-to-end-tests-limitations","text":"Slower run than other tests. More complex to setup and maintain. More prone to flakiness. Ressource intensive.","title":"End-to-End Tests limitations"},{"location":"endToEndTesting/#have-in-mind","text":"In the real world users might come upon unexpected issues that an end-to-end test cannot catch. e.g. - Database connection might time out. - Race conditions between services. - Authentication tokens might expire mid-flow. - Network latency might cause unexpected timeouts.","title":"Have in mind"},{"location":"endToEndTesting/#when-do-we-use-end-to-end-tests","text":"Critical user journeys. Complex workflows spanning multiple pages/views. Features involving multiple services or third-party systems. Areas with high business value.","title":"When do we use End-to-End tests"},{"location":"endToEndTesting/#how-to-run-a-end-to-end-test","text":"To run a test you need to start the server first, You can do that by typing the command below into your CLI. Make sure you are in the project folder. npm run dev Next You will want to run the tests. you can do it in the CLI or more visually using the cypress interactive mode. To run the test in the CLI type the command below in your CLI. npm run test:e2e You can aslo run a specific test by using the command below. npm run test:e2e -- --spec \"cypress/e2e/LoginComp.cy.js\" // or using npx npx run test:e2e --spec \"cypress/e2e/LoginComp.cy.js\" To run the test in cypress interactive mode type the command below. npm cypress open choose E2E Testing followed by a browser. It will open a browser showing all E2E your tests. Simply choose the one you want to run. Notice when using the Cypress interactive mode, everytime you save a file it runs a test.","title":"How to run a End-to-End test"},{"location":"endToEndTesting/#example-of-a-end-to-end-test-in-the-dbi-dashboard","text":"","title":"Example of a End-to-End Test in the DBI Dashboard"},{"location":"endToEndTesting/#signup-flow","text":"This flow tests: Redirecting from the login view to register Password validation Successfull registration describe('Redirect from login to register view', () => { beforeEach(() => { cy.visit('/login'); }); it('should redirect to register page when clicking on register link', () => { cy.get('[data-cy=\"register-link\"]').click(); cy.url().should('include', '/register'); }); }); describe('Register password validation', () => { beforeEach(() => { cy.visit('/register'); cy.get('[data-cy=\"register-name\"]').type('Test User'); cy.get('[data-cy=\"register-email\"]').type(`testuser${Date.now()}@example.com`); }); it('shows error for missing lowercase letter', () => { cy.get('[data-cy=\"register-password\"]').type('PASSWORD123!@#PASSWORD'); cy.get('[data-cy=\"register-confirm-password\"]').type('PASSWORD123!@#PASSWORD'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Adgangskode skal indeholde mindst \u00e9t lille bogstav.').should('be.visible'); }); it('shows error for missing uppercase letter', () => { cy.get('[data-cy=\"register-password\"]').type('password123!@#password'); cy.get('[data-cy=\"register-confirm-password\"]').type('password123!@#password'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Adgangskode skal indeholde mindst \u00e9t stort bogstav.').should('be.visible'); }); it('shows error for missing number', () => { cy.get('[data-cy=\"register-password\"]').type('Password!@#Password!'); cy.get('[data-cy=\"register-confirm-password\"]').type('Password!@#Password!'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Adgangskode skal indeholde mindst \u00e9t tal.').should('be.visible'); }); it('shows error for missing special character', () => { cy.get('[data-cy=\"register-password\"]').type('Password1234Password'); cy.get('[data-cy=\"register-confirm-password\"]').type('Password1234Password'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Adgangskode skal indeholde minst et specialtegn.').should('be.visible'); }); it('shows error for password too short', () => { cy.get('[data-cy=\"register-password\"]').type('Pass1!'); cy.get('[data-cy=\"register-confirm-password\"]').type('Pass1!'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Adgangskode skal indeholde mindst 16 tegn.').should('be.visible'); }); it('shows multiple errors for a very weak password', () => { cy.get('[data-cy=\"register-password\"]').type('abc'); cy.get('[data-cy=\"register-confirm-password\"]').type('abc'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Adgangskode skal indeholde mindst \u00e9t stort bogstav.').should('be.visible'); cy.contains('Adgangskode skal indeholde mindst \u00e9t tal.').should('be.visible'); cy.contains('Adgangskode skal indeholde minst et specialtegn.').should('be.visible'); cy.contains('Adgangskode skal indeholde mindst 16 tegn.').should('be.visible'); }); it('shows error if passwords do not match', () => { cy.get('[data-cy=\"register-password\"]').type('ValidPassword123!@#'); cy.get('[data-cy=\"register-confirm-password\"]').type('DifferentPassword123!@#'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Adgangskoder stemmer ikke overens.').should('be.visible'); }); }); describe('Register flow', () => { beforeEach(() => { cy.visit('/register'); }); it('shows error for email already in use', () => { cy.get('[data-cy=\"register-name\"]').type('Test User'); cy.get('[data-cy=\"register-email\"]').type('test@mail.com'); cy.get('[data-cy=\"register-password\"]').type('ValidPassword123!@#'); cy.get('[data-cy=\"register-confirm-password\"]').type('ValidPassword123!@#'); cy.get('[data-cy=\"register-submit\"]').click(); cy.contains('Ugyldig email').should('be.visible'); }); it('registers a new user with valid data', () => { const uniqueEmail = `testuser${Date.now()}@example.com`; cy.get('[data-cy=\"register-name\"]').type('Test User'); cy.get('[data-cy=\"register-email\"]').type(uniqueEmail); cy.get('[data-cy=\"register-password\"]').type('ValidPassword123!@#'); cy.get('[data-cy=\"register-confirm-password\"]').type('ValidPassword123!@#'); cy.get('[data-cy=\"register-submit\"]').click(); cy.url().should('include', '/dashboard'); }); });","title":"Signup FLow"},{"location":"endToEndTesting/#login-flow","text":"This flow tests: Error handling Successful login redirecting to the dashboard when successfully logging in. describe('Login flow', () => { beforeEach(() => { cy.visit('/login'); }); it('shows error message when the credentials are wrong', () => { cy.get('[data-cy=\"login-email\"]').type('wrong@mail.com'); cy.get('[data-cy=\"login-password\"]').type('wrongpassword'); cy.get('[data-cy=\"login-submit\"]').click(); cy.contains('Forkert email eller adgangskode.').should('be.visible'); }); it('logs in using the right credentials', () => { cy.get('[data-cy=\"login-email\"]').type('test@mail.com'); cy.get('[data-cy=\"login-password\"]').type('password123'); cy.get('[data-cy=\"login-submit\"]').click(); // Expect redirect to dashboard page cy.url().should('include', '/dashboard'); cy.contains('Dashboard').should('exist'); }); });","title":"Login Flow"},{"location":"endToEndTesting/#edit-existing-form","text":"When user wants to edit an existing form. describe('create form modal flow', () => { beforeEach(() => { cy.visit('/login'); cy.get('[data-cy=\"login-email\"]').type('test@mail.com'); cy.get('[data-cy=\"login-password\"]').type('password123'); cy.get('[data-cy=\"login-submit\"]').click(); cy.url().should('include', '/dashboard'); cy.contains('Dashboard').should('exist'); }); it('edit form in form editor', () => { cy.visit('/form-editor/liqwC3KrFzmrhskGFRs7'); cy.contains('Skema Titel').should('exist'); cy.get('[data-cy=\"form-title-input\"]').clear(); cy.get('[data-cy=\"form-title-input\"]').type('Mit nye skema'); cy.get('[data-cy=\"save-form-btn\"]').click(); }); });","title":"Edit existing form"},{"location":"endToEndTesting/#create-new-form-flow","text":"When a user wants to create a new form. Clicks create new form button. Fills in needed information in the form. Creates a form using the drag and drop editor. Save the changes A popup shows saved confirmation. Gets redirected to the form overview.","title":"Create New Form Flow"},{"location":"gettingStarted/","text":"Getting Started Introduction Welcome to the team. This page will tell you everything you need to know when getting started. This guide will walk you through the prerequisites needed, how to install them, setting up your development enviroment, how to run et locally and common troubleshooting errors. after this guide you will be all set and ready to code. Prerequisites Before you start you will need to have the following technologies installed. But don't worry we will guide you through the installation. Git \u2013 We use GitHub for version control. Make sure you have a GitHub account and Git installed on your machine. Node.js \u2013 Enables running JavaScript outside the browser and powers many development tools. Vite \u2013 A fast and modern build tool that provides a smooth and efficient development experience. Vue \u2013 We use Vue 3 with the Composition API as our frontend framework. Sass \u2013 A CSS preprocessor that helps write more maintainable and flexible stylesheets. Pinia \u2013 Our state management library for managing app-wide reactive data in Vue. ESLint \u2013 Ensures consistent code style and helps catch errors early by linting your codebase. SonarCloud/SonarQube \u2013 A cloud-based tool to analyze code quality, detect bugs, vulnerabilities, and code smells. Snyk \u2013 Scans project dependencies for known security vulnerabilities. Cypress \u2013 Used for end-to-end testing to verify the application works as expected from a user\u2019s perspective. Jest \u2013 Used for unit testing to verify individual functions and components behave correctly. vite-svg-loader \u2013 Allows importing SVG files as Vue components, making it easier to work with SVG graphics in your app. vue-router \u2013 The official router for Vue.js, enabling navigation and routing in the web application. firebase \u2013 Google\u2019s platform for backend services like authentication, database, and hosting used in the app. start-server-and-test \u2013 A utility that starts your development server and runs tests automatically once the server is ready. vite-plugin-vue-devtools \u2013 A plugin that integrates Vue Devtools into Vite for easier debugging during development. Installation This guide will help you install all the necessary tools and dependencies required for the project. \u2699\ufe0f Global Prerequisites These tools must be installed globally on your machine . Git We use GitHub for version control. Make sure you have a GitHub account and Git installed. Install Git Download from git-scm.com Verify installation: git --version Node.js (includes npm) Node.js allows you to run JavaScript outside the browser and is required for installing project dependencies. Install Node.js (LTS recommended): Download from nodejs.org Verify installation: node --version npm --version \ud83d\udce6 Install Project Dependencies Once Git and Node.js are installed: Clone the repository: git clone https://github.com/your-org/your-project.git cd your-project Install all dependencies: npm install This will automatically install all required packages listed in package.json, including: Git Node.js Vite Vue Sass Pinia ESLint SonarCloud/SonarQube Snyk Cypress Jest vite-svg-loader vue-router firebase start-server-and-test vite-plugin-vue-devtools No need to install these manually \u2014 npm install handles everything. Running the Project Start the Development Server npm run dev The app will be available at: http://localhost:5173 (or another port if already in use). Run Tests End-to-End (E2E) Tests with Cypress: npm run test:e2e Click here to read more about End-to-End tests Unit Tests with Jest or Cypress Component Testing: npm run test:unit Lint the Codebase npm run lint Troubleshooting If you are having trouble reach out to a team member for help.","title":"Getting Started"},{"location":"gettingStarted/#getting-started","text":"","title":"Getting Started"},{"location":"gettingStarted/#introduction","text":"Welcome to the team. This page will tell you everything you need to know when getting started. This guide will walk you through the prerequisites needed, how to install them, setting up your development enviroment, how to run et locally and common troubleshooting errors. after this guide you will be all set and ready to code.","title":"Introduction"},{"location":"gettingStarted/#prerequisites","text":"Before you start you will need to have the following technologies installed. But don't worry we will guide you through the installation. Git \u2013 We use GitHub for version control. Make sure you have a GitHub account and Git installed on your machine. Node.js \u2013 Enables running JavaScript outside the browser and powers many development tools. Vite \u2013 A fast and modern build tool that provides a smooth and efficient development experience. Vue \u2013 We use Vue 3 with the Composition API as our frontend framework. Sass \u2013 A CSS preprocessor that helps write more maintainable and flexible stylesheets. Pinia \u2013 Our state management library for managing app-wide reactive data in Vue. ESLint \u2013 Ensures consistent code style and helps catch errors early by linting your codebase. SonarCloud/SonarQube \u2013 A cloud-based tool to analyze code quality, detect bugs, vulnerabilities, and code smells. Snyk \u2013 Scans project dependencies for known security vulnerabilities. Cypress \u2013 Used for end-to-end testing to verify the application works as expected from a user\u2019s perspective. Jest \u2013 Used for unit testing to verify individual functions and components behave correctly. vite-svg-loader \u2013 Allows importing SVG files as Vue components, making it easier to work with SVG graphics in your app. vue-router \u2013 The official router for Vue.js, enabling navigation and routing in the web application. firebase \u2013 Google\u2019s platform for backend services like authentication, database, and hosting used in the app. start-server-and-test \u2013 A utility that starts your development server and runs tests automatically once the server is ready. vite-plugin-vue-devtools \u2013 A plugin that integrates Vue Devtools into Vite for easier debugging during development.","title":"Prerequisites"},{"location":"gettingStarted/#installation","text":"This guide will help you install all the necessary tools and dependencies required for the project.","title":"Installation"},{"location":"gettingStarted/#global-prerequisites","text":"These tools must be installed globally on your machine .","title":"\u2699\ufe0f Global Prerequisites"},{"location":"gettingStarted/#git","text":"We use GitHub for version control. Make sure you have a GitHub account and Git installed. Install Git Download from git-scm.com Verify installation: git --version","title":"Git"},{"location":"gettingStarted/#nodejs-includes-npm","text":"Node.js allows you to run JavaScript outside the browser and is required for installing project dependencies. Install Node.js (LTS recommended): Download from nodejs.org Verify installation: node --version npm --version","title":"Node.js (includes npm)"},{"location":"gettingStarted/#install-project-dependencies","text":"Once Git and Node.js are installed: Clone the repository: git clone https://github.com/your-org/your-project.git cd your-project Install all dependencies: npm install This will automatically install all required packages listed in package.json, including: Git Node.js Vite Vue Sass Pinia ESLint SonarCloud/SonarQube Snyk Cypress Jest vite-svg-loader vue-router firebase start-server-and-test vite-plugin-vue-devtools No need to install these manually \u2014 npm install handles everything.","title":"\ud83d\udce6 Install Project Dependencies"},{"location":"gettingStarted/#running-the-project","text":"","title":"Running the Project"},{"location":"gettingStarted/#start-the-development-server","text":"npm run dev The app will be available at: http://localhost:5173 (or another port if already in use).","title":"Start the Development Server"},{"location":"gettingStarted/#run-tests","text":"End-to-End (E2E) Tests with Cypress: npm run test:e2e Click here to read more about End-to-End tests Unit Tests with Jest or Cypress Component Testing: npm run test:unit Lint the Codebase npm run lint","title":"Run Tests"},{"location":"gettingStarted/#troubleshooting","text":"If you are having trouble reach out to a team member for help.","title":"Troubleshooting"},{"location":"githubActions/","text":"Git Workflow Make small incremental changes Commit Frequently Continuous Integration / Deployment We use GitHub Actions to automate testing and deployment through a streamlined CI/CD pipeline . Every code change is verified, previewed, and deployed with minimal friction \u2014 ensuring stability, speed, and quality. Workflow Overview PR.yml Runs on every pull request. Installs dependencies, builds the project, and runs linting. Blocks merging unless all checks pass, which ensuring code quality from the start. firebase-hosting-pull-request.yml Builds the app and deploys a preview version to Firebase Hosting. Lets the team review changes live before they hit production. firebase-hosting-merge.yml Runs on every push to main . Builds and deploys the latest version directly to production via Firebase Hosting Why It Matters Automatic checks on every pull request. Live previews for faster feedback. Instant production deploys on merge. No stale branches \u2014 merged branches auto-delete. This setup enforces code quality, reduces human error, and keeps our production site always up-to-date. CI/CD isn\u2019t just a tool \u2014 it\u2019s our safety net and speed boost. Commits Github messages should be present tense! Messages should be short and describe what they do, max 50 characters. Commit messages can be multi-line, but ALWAYS start with a one-line description. Maximum 72 characters per line. Examples of good and bad commit messages DO \u2705 \"Fix typo in dashboard title\" \u2705 \"Refactor login code for clarity\" \u2705 \"Update member report format for clarity\" \u2705 \"Fix issue causing incorrect user permissions\" \u2705 \"Refactor dashboard styles for consistency\" DON'T \u274c \"fix typo\" \u274c \"update Update login code\" \u274c \"Updates member report, we should discuss if this is rigth next week\" \u274c Fixed a bug \u274c Update stuff","title":"GitHub Actions"},{"location":"githubActions/#git-workflow","text":"Make small incremental changes Commit Frequently","title":"Git Workflow"},{"location":"githubActions/#continuous-integration-deployment","text":"We use GitHub Actions to automate testing and deployment through a streamlined CI/CD pipeline . Every code change is verified, previewed, and deployed with minimal friction \u2014 ensuring stability, speed, and quality.","title":"Continuous Integration / Deployment"},{"location":"githubActions/#workflow-overview","text":"PR.yml Runs on every pull request. Installs dependencies, builds the project, and runs linting. Blocks merging unless all checks pass, which ensuring code quality from the start. firebase-hosting-pull-request.yml Builds the app and deploys a preview version to Firebase Hosting. Lets the team review changes live before they hit production. firebase-hosting-merge.yml Runs on every push to main . Builds and deploys the latest version directly to production via Firebase Hosting","title":"Workflow Overview"},{"location":"githubActions/#why-it-matters","text":"Automatic checks on every pull request. Live previews for faster feedback. Instant production deploys on merge. No stale branches \u2014 merged branches auto-delete. This setup enforces code quality, reduces human error, and keeps our production site always up-to-date. CI/CD isn\u2019t just a tool \u2014 it\u2019s our safety net and speed boost.","title":"Why It Matters"},{"location":"githubActions/#commits","text":"Github messages should be present tense! Messages should be short and describe what they do, max 50 characters. Commit messages can be multi-line, but ALWAYS start with a one-line description. Maximum 72 characters per line.","title":"Commits"},{"location":"githubActions/#examples-of-good-and-bad-commit-messages","text":"","title":"Examples of good and bad commit messages"},{"location":"githubActions/#do","text":"\u2705 \"Fix typo in dashboard title\" \u2705 \"Refactor login code for clarity\" \u2705 \"Update member report format for clarity\" \u2705 \"Fix issue causing incorrect user permissions\" \u2705 \"Refactor dashboard styles for consistency\"","title":"DO"},{"location":"githubActions/#dont","text":"\u274c \"fix typo\" \u274c \"update Update login code\" \u274c \"Updates member report, we should discuss if this is rigth next week\" \u274c Fixed a bug \u274c Update stuff","title":"DON'T"},{"location":"guidelines/","text":"Team Guidelines Introduction These guidelines are designed to ensure consistency, quality, and collaboration across the team. By following these practices, we can work efficiently and deliver high-quality results. Go To Section Communication Coding Standards Refactor Guidelines Code Review Error Handling and Debugging Testing Security Documentation Communication Check Discord at least twice daily Respond to Discord and or Messenger messages within 4 hours Attend meetings setup in advance Stay updated on Trello Coding Standards Use camelCase for variable names and PascalCase for class and filenames. We use the BEM naming structure. Write self-documenting code with meaningful variable and function names. Avoid deep nesting and keep functions small and focused. End multiline elements with a dangling Comma. Use === (eqeqeq) not ==! Indentations must be 2 spaces. No Eval - for safety. No trailing spaces. No unused variables. No Var. Use let or preferably const instead. Use single quotes not double quotes End lines of code with semicolon (;). Refactor Guidelines Best Practices: - Test after each refactoring - Keep functions small end focused - Avoid deep nesting - Use constants for magic numbers and strings Single Responsibility Principle Each Function / Class should have one responsibility class User { constructor(name, email) { this.name = name; this.email = email; } sendEmail(message) { console.log(`Sending email to ${this.email}: ${message}`); } } Don't Repeat Yourself Every piece of code should have a single representation Avoid copy/pasting code Create reusable functions and utilities // Do this function calculateArea(length, width) { return length * width; } const area1 = calculateArea (length1, width1); const area2 = calculateArea (length2, width2); const area3 = calculateArea (length3, width3); // Not this const area1 = length1 * width1; const area2 = length2 * width2; const area3 = length3 * width3; Keep It Simple Stupid Simpler code is easier to maintain Avoid clever tricks Clear and straightforward solutions are better Remember code is read more often than it is written // Do this - Simple code, easy to read function getUserStatus(age, isMember) { if (age >= 18) { if(isMember) { return \"Adult Member\"; } else { return \"Adult Non-Member\"; } } else { if (isMember) { return \"Minor Member\"; } else { return \"Minor Non-Member\"; } } } // Not this - Clever but hard to read function getUserStatus (age, isMember) { const status = >= 18 ? \"Adult\" : \"Minor\"; return `${status} ${isMember ? \"Member\" : \"Non-Member\"}`; } You Aren't Going To Need It Don't add it unless you need it Focus on current requirements class User { constructor(name, email) { this.name = name; this.email = email; this.phonenumber = phonenumber; // We might need this later this.preferences = preferences; // Also for later use } } Writing Self-Documenting Code Use explanitory variables, functions etc. //Good const currentDate = new Date(); const timestamp = currentDate.getTime(;) //Bad const d = new Date(); const n = currentDate.getTime(;) //Good function validateUserInput(formData) { // ... Validates user input } //Bad function data(form) { // ... does something with data } Code Comments Explain why, not what Keep Comments up to date Don't overuse comments /** * Calculates the total price including tax and discounts * @param {number} basePrise - the original price * @param {number} taxRate - taxrate as decimal (e.g., 0.2 for 20%) * @param {boolean} hasDiscount - Whether to standard discount * @returns {number} the final price */ function calculateFinalPrice(basePrice, taxRate, hasDiscount) { // implementation } Code Review Ensure code adheres to the coding standards. Check for sufficient test coverage. Provide constructive feedback and suggest improvements. Error Handling and Debugging Log errors to the console or terminal. Provide user-friendly error messages. Avoid exposing sensitive information in error messages. Testing Write unit tests for all new features. Use SonarQube for JavaScript testing. Maintain at least 80% test coverage. Security Security Never commit sensitive data (e.g., API keys, passwords). Validate all user inputs to prevent injection attacks. Use HTTPS for all API requests.","title":"Guidelines"},{"location":"guidelines/#team-guidelines","text":"","title":"Team Guidelines"},{"location":"guidelines/#introduction","text":"These guidelines are designed to ensure consistency, quality, and collaboration across the team. By following these practices, we can work efficiently and deliver high-quality results.","title":"Introduction"},{"location":"guidelines/#go-to-section","text":"Communication Coding Standards Refactor Guidelines Code Review Error Handling and Debugging Testing Security Documentation","title":"Go To Section"},{"location":"guidelines/#communication","text":"Check Discord at least twice daily Respond to Discord and or Messenger messages within 4 hours Attend meetings setup in advance Stay updated on Trello","title":"Communication"},{"location":"guidelines/#coding-standards","text":"Use camelCase for variable names and PascalCase for class and filenames. We use the BEM naming structure. Write self-documenting code with meaningful variable and function names. Avoid deep nesting and keep functions small and focused. End multiline elements with a dangling Comma. Use === (eqeqeq) not ==! Indentations must be 2 spaces. No Eval - for safety. No trailing spaces. No unused variables. No Var. Use let or preferably const instead. Use single quotes not double quotes End lines of code with semicolon (;).","title":"Coding Standards"},{"location":"guidelines/#refactor-guidelines","text":"Best Practices: - Test after each refactoring - Keep functions small end focused - Avoid deep nesting - Use constants for magic numbers and strings Single Responsibility Principle Each Function / Class should have one responsibility class User { constructor(name, email) { this.name = name; this.email = email; } sendEmail(message) { console.log(`Sending email to ${this.email}: ${message}`); } } Don't Repeat Yourself Every piece of code should have a single representation Avoid copy/pasting code Create reusable functions and utilities // Do this function calculateArea(length, width) { return length * width; } const area1 = calculateArea (length1, width1); const area2 = calculateArea (length2, width2); const area3 = calculateArea (length3, width3); // Not this const area1 = length1 * width1; const area2 = length2 * width2; const area3 = length3 * width3; Keep It Simple Stupid Simpler code is easier to maintain Avoid clever tricks Clear and straightforward solutions are better Remember code is read more often than it is written // Do this - Simple code, easy to read function getUserStatus(age, isMember) { if (age >= 18) { if(isMember) { return \"Adult Member\"; } else { return \"Adult Non-Member\"; } } else { if (isMember) { return \"Minor Member\"; } else { return \"Minor Non-Member\"; } } } // Not this - Clever but hard to read function getUserStatus (age, isMember) { const status = >= 18 ? \"Adult\" : \"Minor\"; return `${status} ${isMember ? \"Member\" : \"Non-Member\"}`; } You Aren't Going To Need It Don't add it unless you need it Focus on current requirements class User { constructor(name, email) { this.name = name; this.email = email; this.phonenumber = phonenumber; // We might need this later this.preferences = preferences; // Also for later use } } Writing Self-Documenting Code Use explanitory variables, functions etc. //Good const currentDate = new Date(); const timestamp = currentDate.getTime(;) //Bad const d = new Date(); const n = currentDate.getTime(;) //Good function validateUserInput(formData) { // ... Validates user input } //Bad function data(form) { // ... does something with data } Code Comments Explain why, not what Keep Comments up to date Don't overuse comments /** * Calculates the total price including tax and discounts * @param {number} basePrise - the original price * @param {number} taxRate - taxrate as decimal (e.g., 0.2 for 20%) * @param {boolean} hasDiscount - Whether to standard discount * @returns {number} the final price */ function calculateFinalPrice(basePrice, taxRate, hasDiscount) { // implementation }","title":"Refactor Guidelines"},{"location":"guidelines/#code-review","text":"Ensure code adheres to the coding standards. Check for sufficient test coverage. Provide constructive feedback and suggest improvements.","title":"Code Review"},{"location":"guidelines/#error-handling-and-debugging","text":"Log errors to the console or terminal. Provide user-friendly error messages. Avoid exposing sensitive information in error messages.","title":"Error Handling and Debugging"},{"location":"guidelines/#testing","text":"Write unit tests for all new features. Use SonarQube for JavaScript testing. Maintain at least 80% test coverage.","title":"Testing"},{"location":"guidelines/#security","text":"","title":"Security"},{"location":"guidelines/#security_1","text":"Never commit sensitive data (e.g., API keys, passwords). Validate all user inputs to prevent injection attacks. Use HTTPS for all API requests.","title":"Security"},{"location":"staticCodeAnalysis/","text":"Static Code Analysis Snyk is used to detect and manage security vulnerabilities in project dependencies. It integrates into the development and CI/CD process to continuously scan for known threats and suggest appropriate fixes. Scans for vulnerabilities in open source dependencies, containers, IaC, and code. Identifies license issues in third-party packages. Provides fix suggestions such as secure versions or configuration changes. Integrates with Git and CI/CD to catch issues early in the pipeline. Can auto-create pull requests to fix vulnerabilities automatically.","title":"Static Code Analysis"},{"location":"staticCodeAnalysis/#static-code-analysis","text":"Snyk is used to detect and manage security vulnerabilities in project dependencies. It integrates into the development and CI/CD process to continuously scan for known threats and suggest appropriate fixes. Scans for vulnerabilities in open source dependencies, containers, IaC, and code. Identifies license issues in third-party packages. Provides fix suggestions such as secure versions or configuration changes. Integrates with Git and CI/CD to catch issues early in the pipeline. Can auto-create pull requests to fix vulnerabilities automatically.","title":"Static Code Analysis"},{"location":"testing/","text":"Test and Analysis Introduction Ensuring code quality, performance, and reliability is a critical part of the development lifecycle. This section outlines the tools and strategies used in our project to test, analyze, and monitor the application at various levels. We employ a combination of unit testing , end-to-end (E2E) testing , code quality analysis , and performance monitoring to ensure the application functions correctly and efficiently. Unit Test Frameworks and Tools Unit Testing is handled through frameworks such as Jest , allowing us to test individual functions and components in isolation. Jest Jest is used for unit testing JavaScript and TypeScript code. It provides fast test execution, built-in mocking, snapshot testing, and code coverage reports. Jest is integrated into our CI/CD pipeline to catch regressions early. End-to-End (E2E) Teststrategies Cypress Cypress is used for end-to-end (E2E) testing , simulating real user interactions to validate that the entire system behaves as expected. Static Code Analysis Snyk is used to detect and manage security vulnerabilities in project dependencies. It integrates into the development and CI/CD process to continuously scan for known threats and suggest appropriate fixes. SonarQube SonarQube is integrated into our workflow to analyze code for quality, maintainability, bugs, and vulnerabilities. APM (Application Performance Monitoring) We also assess the application's performance using Application Performance Monitoring (APM) tools and track benchmarks to identify and optimize slow or resource-intensive operations. Performance and benchmarks","title":"Testing and Analysis"},{"location":"testing/#test-and-analysis","text":"","title":"Test and Analysis"},{"location":"testing/#introduction","text":"Ensuring code quality, performance, and reliability is a critical part of the development lifecycle. This section outlines the tools and strategies used in our project to test, analyze, and monitor the application at various levels. We employ a combination of unit testing , end-to-end (E2E) testing , code quality analysis , and performance monitoring to ensure the application functions correctly and efficiently.","title":"Introduction"},{"location":"testing/#unit-test-frameworks-and-tools","text":"Unit Testing is handled through frameworks such as Jest , allowing us to test individual functions and components in isolation.","title":"Unit Test Frameworks and Tools"},{"location":"testing/#jest","text":"Jest is used for unit testing JavaScript and TypeScript code. It provides fast test execution, built-in mocking, snapshot testing, and code coverage reports. Jest is integrated into our CI/CD pipeline to catch regressions early.","title":"Jest"},{"location":"testing/#end-to-end-e2e-teststrategies","text":"","title":"End-to-End (E2E) Teststrategies"},{"location":"testing/#cypress","text":"Cypress is used for end-to-end (E2E) testing , simulating real user interactions to validate that the entire system behaves as expected.","title":"Cypress"},{"location":"testing/#static-code-analysis","text":"Snyk is used to detect and manage security vulnerabilities in project dependencies. It integrates into the development and CI/CD process to continuously scan for known threats and suggest appropriate fixes.","title":"Static Code Analysis"},{"location":"testing/#sonarqube","text":"SonarQube is integrated into our workflow to analyze code for quality, maintainability, bugs, and vulnerabilities.","title":"SonarQube"},{"location":"testing/#apm-application-performance-monitoring","text":"We also assess the application's performance using Application Performance Monitoring (APM) tools and track benchmarks to identify and optimize slow or resource-intensive operations.","title":"APM (Application Performance Monitoring)"},{"location":"testing/#performance-and-benchmarks","text":"","title":"Performance and benchmarks"},{"location":"unitTesting/","text":"Unit Testing Unit tests are fast and focused tests that verify the behavior of individual functions or components in isolation. Unlike End-to-End (E2E) tests, which validate complete user flows, unit tests ensure that the building blocks of your codebase work as expected. Purpose of Unit Testing Validates small, isolated units of logic (e.g., functions like sort and filter ). Catches bugs early in the development cycle, before integration or deployment. Increases code quality and makes refactoring safer. Provides fast feedback during development. Example: utils.js In this example, we are testing two utility functions: sort and filter . These are used to sort and filter arrays of objects. The tests are written using Jest . import { sort, filter } from '../utils.js'; const arr = [ { name: 'Charlie' }, { name: 'Alice' }, { name: 'Bob' }, ]; sort function What\u2019s being tested: Sorting an array in ascending and descending order based on a key (e.g., name).. Ensures the original array remains unchanged by working on a copy. describe('sort', () => { it('sorts array ascending by key', () => { const result = sort([...arr], 'name', 'asc'); expect(result.map(x => x.name)).toEqual(['Charlie', 'Bob', 'Alice']); }); it('sorts array descending by key', () => { const result = sort([...arr], 'name', 'desc'); expect(result.map(x => x.name)).toEqual(['Alice', 'Bob', 'Charlie']); }); }); Note: The expected output in the test might seem counterintuitive \u2014 \u201cascending\u201d returns ['Charlie', 'Bob', 'Alice']. This could be a logic bug or a naming mismatch in the actual implementation. filter function What\u2019s being tested: Case-insensitive filtering based on a string match within a specific key. Returns the original array if the search term is empty or null. Returns an empty array if there are no matches. describe('filter', () => { it('filters array by key and term (case-insensitive)', () => { expect(filter(arr, 'name', 'ali')).toEqual([{ name: 'Alice' }]); expect(filter(arr, 'name', 'BO')).toEqual([{ name: 'Bob' }]); }); it('returns original array if term is empty', () => { expect(filter(arr, 'name', '')).toEqual(arr); expect(filter(arr, 'name', null)).toEqual(arr); }); it('returns empty array if no match', () => { expect(filter(arr, 'name', 'zzz')).toEqual([]); }); }); How to Run Unit Tests You can run all unit tests using this command: npm run test To run a specific test file (e.g., utils.test.js): npm run test -- utils.test.js you can also use watch mode to run test automatic, when saving files npm run test -- --watch Summary Unit tests are great for fast and focused feedback. They work best for logic-heavy parts of your code (pure functions, helpers). Pair them with integration and E2E tests for full confidence.","title":"Unit Testing"},{"location":"unitTesting/#unit-testing","text":"Unit tests are fast and focused tests that verify the behavior of individual functions or components in isolation. Unlike End-to-End (E2E) tests, which validate complete user flows, unit tests ensure that the building blocks of your codebase work as expected.","title":"Unit Testing"},{"location":"unitTesting/#purpose-of-unit-testing","text":"Validates small, isolated units of logic (e.g., functions like sort and filter ). Catches bugs early in the development cycle, before integration or deployment. Increases code quality and makes refactoring safer. Provides fast feedback during development.","title":"Purpose of Unit Testing"},{"location":"unitTesting/#example-utilsjs","text":"In this example, we are testing two utility functions: sort and filter . These are used to sort and filter arrays of objects. The tests are written using Jest . import { sort, filter } from '../utils.js'; const arr = [ { name: 'Charlie' }, { name: 'Alice' }, { name: 'Bob' }, ];","title":"Example: utils.js"},{"location":"unitTesting/#sort-function","text":"","title":"sort function"},{"location":"unitTesting/#whats-being-tested","text":"Sorting an array in ascending and descending order based on a key (e.g., name).. Ensures the original array remains unchanged by working on a copy. describe('sort', () => { it('sorts array ascending by key', () => { const result = sort([...arr], 'name', 'asc'); expect(result.map(x => x.name)).toEqual(['Charlie', 'Bob', 'Alice']); }); it('sorts array descending by key', () => { const result = sort([...arr], 'name', 'desc'); expect(result.map(x => x.name)).toEqual(['Alice', 'Bob', 'Charlie']); }); }); Note: The expected output in the test might seem counterintuitive \u2014 \u201cascending\u201d returns ['Charlie', 'Bob', 'Alice']. This could be a logic bug or a naming mismatch in the actual implementation.","title":"What\u2019s being tested:"},{"location":"unitTesting/#filter-function","text":"","title":"filter function"},{"location":"unitTesting/#whats-being-tested_1","text":"Case-insensitive filtering based on a string match within a specific key. Returns the original array if the search term is empty or null. Returns an empty array if there are no matches. describe('filter', () => { it('filters array by key and term (case-insensitive)', () => { expect(filter(arr, 'name', 'ali')).toEqual([{ name: 'Alice' }]); expect(filter(arr, 'name', 'BO')).toEqual([{ name: 'Bob' }]); }); it('returns original array if term is empty', () => { expect(filter(arr, 'name', '')).toEqual(arr); expect(filter(arr, 'name', null)).toEqual(arr); }); it('returns empty array if no match', () => { expect(filter(arr, 'name', 'zzz')).toEqual([]); }); });","title":"What\u2019s being tested:"},{"location":"unitTesting/#how-to-run-unit-tests","text":"You can run all unit tests using this command: npm run test To run a specific test file (e.g., utils.test.js): npm run test -- utils.test.js you can also use watch mode to run test automatic, when saving files npm run test -- --watch","title":"How to Run Unit Tests"},{"location":"unitTesting/#summary","text":"Unit tests are great for fast and focused feedback. They work best for logic-heavy parts of your code (pure functions, helpers). Pair them with integration and E2E tests for full confidence.","title":"Summary"},{"location":"versioncontrol/","text":"Changelog and Version Control Introduction This document outlines the version control practices for the project and provides a changelog to track the history of changes. By following these guidelines, we ensure a consistent and organized workflow. Version Control Guidelines We use Git for version control, with GitHub as our hosting platform. This allows for efficient collaboration, history tracking, and integration with CI/CD pipelines. Branching Strategy We use GitHub Flow as our branching strategy to ensure a structured and conflict-free collaboration process. Workflow All new work is done in feature branches , created from the main branch. When a feature is complete, a pull request (PR) is opened to merge the changes into main . Each PR must undergo: Code review by at least one team member. Automated status checks (e.g., build, linting, tests). Only when all checks pass and the code is approved, it can be merged. The main branch always contains stable, deploy-ready code. GitHub Branch Protection Rules To safeguard our codebase and enforce quality control, we apply the following rules to the main branch: Restrict deletions: Prevents accidental deletion of the main branch. Require pull request before merging: Direct commits to main are blocked. Require status checks to pass: Ensures code meets quality standards before merging. Block force pushes: Protects commit history from being overwritten. These rules are tightly integrated into our CI/CD pipeline and help maintain a high standard of code quality across the team. Naming Conventions Main Branch: Contains production-ready code. Feature Branches: Used for developing new features (e.g., feature/feature-name ). Bugfix Branches: Used for fixing bugs (e.g., bugfix/bug-description ). Documentation: Used for writing documentation (e.g., docs/update-section-name ). Refactor: Used for refactoring code (e.g., refactor/component-or-scope ). Test: Used for testing code (e.g., test/test-name-component-or-scope ). Chore: Used for maintenance tasks (e.g., chore/task-name-component-or-scope ). Commit Message Conventions Use semantic commit messages: feat: for new features. fix: for bug fixes. docs: for documentation updates. refactor: for code refactoring. test: for adding or updating tests. chore: for maintenance tasks. Pull Request Process Create a pull request for merging feature/bugfix branches into the main branch. Request a code review from at least one team member. Ensure all tests pass before merging. Changelog v1.0.0 - 2025-03-18 Initial release of the project. Added core features: User authentication. Dashboard with data visualization. API integration. v1.1.0 - 2025-03-25 Added new features: Dark mode support. Export data functionality. Fixed bugs: Resolved issue with login form validation. Best Practices Commit frequently with meaningful messages. Avoid committing sensitive data (e.g., API keys, passwords). Keep your feature branch up-to-date with the main branch. Resolve merge conflicts promptly.","title":"Changelog and Versioncontrol"},{"location":"versioncontrol/#changelog-and-version-control","text":"","title":"Changelog and Version Control"},{"location":"versioncontrol/#introduction","text":"This document outlines the version control practices for the project and provides a changelog to track the history of changes. By following these guidelines, we ensure a consistent and organized workflow.","title":"Introduction"},{"location":"versioncontrol/#version-control-guidelines","text":"We use Git for version control, with GitHub as our hosting platform. This allows for efficient collaboration, history tracking, and integration with CI/CD pipelines.","title":"Version Control Guidelines"},{"location":"versioncontrol/#branching-strategy","text":"We use GitHub Flow as our branching strategy to ensure a structured and conflict-free collaboration process.","title":"Branching Strategy"},{"location":"versioncontrol/#workflow","text":"All new work is done in feature branches , created from the main branch. When a feature is complete, a pull request (PR) is opened to merge the changes into main . Each PR must undergo: Code review by at least one team member. Automated status checks (e.g., build, linting, tests). Only when all checks pass and the code is approved, it can be merged. The main branch always contains stable, deploy-ready code.","title":"Workflow"},{"location":"versioncontrol/#github-branch-protection-rules","text":"To safeguard our codebase and enforce quality control, we apply the following rules to the main branch: Restrict deletions: Prevents accidental deletion of the main branch. Require pull request before merging: Direct commits to main are blocked. Require status checks to pass: Ensures code meets quality standards before merging. Block force pushes: Protects commit history from being overwritten. These rules are tightly integrated into our CI/CD pipeline and help maintain a high standard of code quality across the team.","title":"GitHub Branch Protection Rules"},{"location":"versioncontrol/#naming-conventions","text":"Main Branch: Contains production-ready code. Feature Branches: Used for developing new features (e.g., feature/feature-name ). Bugfix Branches: Used for fixing bugs (e.g., bugfix/bug-description ). Documentation: Used for writing documentation (e.g., docs/update-section-name ). Refactor: Used for refactoring code (e.g., refactor/component-or-scope ). Test: Used for testing code (e.g., test/test-name-component-or-scope ). Chore: Used for maintenance tasks (e.g., chore/task-name-component-or-scope ).","title":"Naming Conventions"},{"location":"versioncontrol/#commit-message-conventions","text":"Use semantic commit messages: feat: for new features. fix: for bug fixes. docs: for documentation updates. refactor: for code refactoring. test: for adding or updating tests. chore: for maintenance tasks.","title":"Commit Message Conventions"},{"location":"versioncontrol/#pull-request-process","text":"Create a pull request for merging feature/bugfix branches into the main branch. Request a code review from at least one team member. Ensure all tests pass before merging.","title":"Pull Request Process"},{"location":"versioncontrol/#changelog","text":"","title":"Changelog"},{"location":"versioncontrol/#v100-2025-03-18","text":"Initial release of the project. Added core features: User authentication. Dashboard with data visualization. API integration.","title":"v1.0.0 - 2025-03-18"},{"location":"versioncontrol/#v110-2025-03-25","text":"Added new features: Dark mode support. Export data functionality. Fixed bugs: Resolved issue with login form validation.","title":"v1.1.0 - 2025-03-25"},{"location":"versioncontrol/#best-practices","text":"Commit frequently with meaningful messages. Avoid committing sensitive data (e.g., API keys, passwords). Keep your feature branch up-to-date with the main branch. Resolve merge conflicts promptly.","title":"Best Practices"}]}